<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Client Testing &#8212; FoundationDB 7.1</title>
    
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-3.3.4/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-3.3.4/css/bootstrap-theme.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '7.1.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="_static/bootstrap-3.3.4/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Using FoundationDB Clients" href="api-general.html" />
    <link rel="prev" title="Data Modeling" href="data-modeling.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html">
          FoundationDB</a>
        <span class="navbar-text navbar-version pull-left"><b>7.1</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="contents.html">Site Map</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Client Testing</a></li>
<li><a class="reference internal" href="#testing-error-handling-with-buggify">Testing Error Handling with Buggify</a><ul>
<li><a class="reference internal" href="#options-to-control-buggify">Options to Control Buggify</a></li>
</ul>
</li>
<li><a class="reference internal" href="#simulation-and-cluster-workloads">Simulation and Cluster Workloads</a><ul>
<li><a class="reference internal" href="#general-overview">General Overview</a></li>
<li><a class="reference internal" href="#parallelism-and-determinism">Parallelism and Determinism</a></li>
<li><a class="reference internal" href="#finding-the-shared-object">Finding the Shared Object</a></li>
<li><a class="reference internal" href="#implementing-a-c-workload">Implementing a C++ Workload</a></li>
<li><a class="reference internal" href="#implementing-a-java-workload">Implementing a Java Workload</a></li>
<li><a class="reference internal" href="#running-a-workload-in-the-simulator">Running a Workload in the Simulator</a><ul>
<li><a class="reference internal" href="#write-the-test">Write the Test</a><ul>
<li><a class="reference internal" href="#how-to-set-the-class-path-correctly">How to set the Class Path correctly</a></li>
</ul>
</li>
<li><a class="reference internal" href="#run-the-simulator">Run the simulator</a></li>
</ul>
</li>
<li><a class="reference internal" href="#running-a-workload-on-an-actual-cluster">Running a Workload on an actual Cluster</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="data-modeling.html" title="Previous Chapter: Data Modeling"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; Data Modeling</span>
    </a>
  </li>
  <li>
    <a href="api-general.html" title="Next Chapter: Using FoundationDB Clients"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">Using Foundat... &raquo;</span>
    </a>
  </li>
              
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary"><ul>
<li><a class="reference internal" href="#">Client Testing</a></li>
<li><a class="reference internal" href="#testing-error-handling-with-buggify">Testing Error Handling with Buggify</a><ul>
<li><a class="reference internal" href="#options-to-control-buggify">Options to Control Buggify</a></li>
</ul>
</li>
<li><a class="reference internal" href="#simulation-and-cluster-workloads">Simulation and Cluster Workloads</a><ul>
<li><a class="reference internal" href="#general-overview">General Overview</a></li>
<li><a class="reference internal" href="#parallelism-and-determinism">Parallelism and Determinism</a></li>
<li><a class="reference internal" href="#finding-the-shared-object">Finding the Shared Object</a></li>
<li><a class="reference internal" href="#implementing-a-c-workload">Implementing a C++ Workload</a></li>
<li><a class="reference internal" href="#implementing-a-java-workload">Implementing a Java Workload</a></li>
<li><a class="reference internal" href="#running-a-workload-in-the-simulator">Running a Workload in the Simulator</a><ul>
<li><a class="reference internal" href="#write-the-test">Write the Test</a><ul>
<li><a class="reference internal" href="#how-to-set-the-class-path-correctly">How to set the Class Path correctly</a></li>
</ul>
</li>
<li><a class="reference internal" href="#run-the-simulator">Run the simulator</a></li>
</ul>
</li>
<li><a class="reference internal" href="#running-a-workload-on-an-actual-cluster">Running a Workload on an actual Cluster</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    <div class="col-md-9 content">
      
  <div class="section" id="client-testing">
<h1>Client Testing</h1>
</div>
<div class="section" id="testing-error-handling-with-buggify">
<h1>Testing Error Handling with Buggify</h1>
<p>FoundationDB clients need to handle errors correctly. Wrong error handling can lead to many bugs - in the worst case it can
lead to a corrupted database. Because of this it is important that an application or layer author tests properly their
application during failure scenarios. But this is non-trivial. In a development environment cluster failures are very
unlikely and it is therefore possible that certain types of exceptions are never tested in a controlled environment.</p>
<p>The simplest way of testing for these kind of errors is a simple mechanism called <code class="docutils literal"><span class="pre">Buggify</span></code>. If this option is enabled
in the client, the client will randomly throw errors that an application might see in a production environment. Enable this
option in testing will greatly improve the probability that error handling is tested properly.</p>
<div class="section" id="options-to-control-buggify">
<h2>Options to Control Buggify</h2>
<p>There are four network options to control the buggify behavior. By default, buggify is disabled (as it will behave in a way
that is not desirable in a production environment). The options to control buggify are:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">buggify_enable</span></code>
This option takes no argument and will enable buggify.</li>
<li><code class="docutils literal"><span class="pre">buggify_disable</span></code>
This can be used to disable buggify again.</li>
<li><code class="docutils literal"><span class="pre">client_buggify_section_activated_probability</span></code> (default <code class="docutils literal"><span class="pre">25</span></code>)
A number between 0 and 100.</li>
<li><code class="docutils literal"><span class="pre">client_buggify_section_fired_probability</span></code> (default <code class="docutils literal"><span class="pre">25</span></code>)
A number between 0 and 100.</li>
</ul>
<p>The way buggify works is by enabling sections in the code first that get only executed with a certain probability. Generally
these code sections will simply introduce a synthetic error.</p>
<p>When a section is passed for the first time, the client library will decide randomly whether that code section will be enabled
or not. It will be enabled with a probability of <code class="docutils literal"><span class="pre">client_buggify_section_activated_probability</span></code>.</p>
<p>Whenever the client executes a buggify-enabled code-block, it will randomly execute it. This is to make sure that a certain
exception doesn&#8217;t always fire. The probably for executing such a section is <code class="docutils literal"><span class="pre">client_buggify_section_fired_probability</span></code>.</p>
</div>
</div>
<div class="section" id="simulation-and-cluster-workloads">
<h1>Simulation and Cluster Workloads</h1>
<p>FoundationDB comes with its own testing framework. Tests are implemented as workloads. A workload is nothing more than a class
that gets called by server processes running the <code class="docutils literal"><span class="pre">tester</span></code> role. Additionally, a <code class="docutils literal"><span class="pre">fdbserver</span></code> process can run a simulator that
simulates a full fdb cluster with several machines and different configurations in one process. This simulator can run the same
workloads you can run on a real cluster. It will also inject random failures like network partitions and disk failures.</p>
<p>This tutorial explains how one can implement a workload, how one can orchestrate a workload on a cluster with multiple clients, and
how one can run a workload within a simulator. Running in a simulator is also useful as it does not require any setup: you can simply
run one command that will provide you with a fully functional FoundationDB cluster.</p>
<div class="section" id="general-overview">
<h2>General Overview</h2>
<p>Workloads in FoundationDB are generally compiled into the binary. However, FoundationDB also provides the ability to load workloads
dynamically. This is done through <code class="docutils literal"><span class="pre">dlopen</span></code> (on Unix like operating systems) or <code class="docutils literal"><span class="pre">LoadLibrary</span></code> (on Windows).</p>
</div>
<div class="section" id="parallelism-and-determinism">
<h2>Parallelism and Determinism</h2>
<p>A workload can run either in a simulation or on a real cluster. In simulation, <code class="docutils literal"><span class="pre">fdbserver</span></code> will simulate a whole cluster and will
use a deterministic random number generator to simulate random behavior and random failures. This random number generator is initialized
with a random seed. In case of a test failure, the user can reuse the given seed and rerun the same test in order to further observe
and debug the behavior.</p>
<p>However, this will only work as long as the workload doesn&#8217;t introduce any non-deterministic behavior. One example of non-deterministic
behavior is the running multiple threads.</p>
<p>The workload is created in the main network thread and it will run in the main network thread. Because of this, using any blocking
function (for example <code class="docutils literal"><span class="pre">blockUntilReady</span></code> on a future object) will result in a deadlock. Using the callback API is therefore required
if one wants to keep the simulator&#8217;s deterministic behavior.</p>
<p>For existing applications and layers, however, not using the blocking API might not be an option. For these use-cases, a user can chose
to start new threads and use the blocking API from within these threads. This will mean that test failures will be non-deterministic and
might be hard to reproduce.</p>
<p>To start a new thread, one has to &#8220;bind&#8221; operating system threads to their simulated processes. This can be done by setting the
<code class="docutils literal"><span class="pre">ProcessId</span></code> in the child threads when they get created. In Java this is done by only starting new threads through the provided
<code class="docutils literal"><span class="pre">Executor</span></code>. In the C++ API one can use the <code class="docutils literal"><span class="pre">FDBWorkloadContext</span></code> to do that. For example:</p>
<div class="highlight-C++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Fun</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="n">startThread</span><span class="p">(</span><span class="n">FDBWorkloadContext</span><span class="o">*</span><span class="w"> </span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">Fun</span><span class="w"> </span><span class="n">fun</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">processId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="o">-&gt;</span><span class="n">getProcessID</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">([</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">processID</span><span class="p">,</span><span class="w"> </span><span class="n">fun</span><span class="p">](</span><span class="w"></span>
<span class="w">        </span><span class="n">context</span><span class="o">-&gt;</span><span class="n">setProcessID</span><span class="p">(</span><span class="n">processID</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">fun</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="finding-the-shared-object">
<h2>Finding the Shared Object</h2>
<p>When the test starts, <code class="docutils literal"><span class="pre">fdbserver</span></code> needs to find the shared object to load. The name of this shared object has to be provided.</p>
<p>For Java, we provide an implementation in <code class="docutils literal"><span class="pre">libjava_workloads.so</span></code> which can be built out of the sources. The tester will look
for the key <code class="docutils literal"><span class="pre">libraryName</span></code> in the test file which should be the name of the library without extension and without the <code class="docutils literal"><span class="pre">lib</span></code>
prefix (so <code class="docutils literal"><span class="pre">java_workloads</span></code> if you want to write a Java workload).</p>
<p>By default, the process will look for the library in the directory <code class="docutils literal"><span class="pre">../shared/foundationdb/</span></code> relative to the location of the
<code class="docutils literal"><span class="pre">fdbserver</span></code> binary. If the library is somewhere else on the system, one can provide the absolute path to the library (only
the folder, not the file name) in the test file with the <code class="docutils literal"><span class="pre">libraryPath</span></code> option.</p>
</div>
<div class="section" id="implementing-a-c-workload">
<h2>Implementing a C++ Workload</h2>
<p>In order to implement a workload, one has to build a shared library that links against the fdb client library. This library has to
exppse a function (with C linkage) called workloadFactory which needs to return a pointer to an object of type <code class="docutils literal"><span class="pre">FDBWorkloadFactory</span></code>.
This mechanism allows the other to implement as many workloads within one library as she wants. To do this the pure virtual classes
<code class="docutils literal"><span class="pre">FDBWorkloadFactory</span></code> and <code class="docutils literal"><span class="pre">FDBWorkload</span></code> have to be implemented.</p>
<dl class="function">
<dt id="_CPPv215workloadFactoryP9FDBLogger">
<span id="workloadFactory__FDBLoggerP"></span>FDBWorkloadFactory *<code class="descclassname"></code><code class="descname">workloadFactory</code><span class="sig-paren">(</span>FDBLogger *<span class="sig-paren">)</span><br /></dt>
<dd><p>This function has to be defined within the shared library and will be called by <code class="docutils literal"><span class="pre">fdbserver</span></code> for looking up a specific workload.
<code class="docutils literal"><span class="pre">FDBLogger</span></code> will be passed and is guaranteed to survive for the lifetime of the process. This class can be used to write to the
FoundationDB traces. Logging anything with severity <code class="docutils literal"><span class="pre">FDBSeverity::Error</span></code> will result in a hard test failure. This function needs
to have c-linkage, so define it in a <code class="docutils literal"><span class="pre">extern</span> <span class="pre">&quot;C&quot;</span></code> block.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N11FDBWorkload6createERKNSt6stringE">
<span id="FDBWorkload::create__ssCR"></span>std::shared_ptr&lt;FDBWorkload&gt; <code class="descclassname">FDBWorkload::</code><code class="descname">create</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>name</em><span class="sig-paren">)</span><br /></dt>
<dd><p>This is the only method to be implemented in <code class="docutils literal"><span class="pre">FDBWorkloadFactory</span></code>. If the test file contains a key-value pair <code class="docutils literal"><span class="pre">workloadName</span></code>
the value will be passed to this method (empty string otherwise). This way, a library author can implement many workloads in one
library and use the test file to chose which one to run (or run multiple workloads either concurrently or serially).</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK11FDBWorkload11descriptionEv">
<span id="FDBWorkload::descriptionC"></span>std::string <code class="descclassname">FDBWorkload::</code><code class="descname">description</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>This method has to return the name of the workload. This can be a static name and is primarily used for tracing.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N11FDBWorkload4initEP18FDBWorkloadContext">
<span id="FDBWorkload::init__FDBWorkloadContextP"></span>bool <code class="descclassname">FDBWorkload::</code><code class="descname">init</code><span class="sig-paren">(</span>FDBWorkloadContext *<em>context</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Right after initialization</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N11FDBWorkload5setupEP11FDBDatabase14GenericPromiseIbE">
<span id="FDBWorkload::setup__FDBDatabaseP.GenericPromise:b:"></span>void <code class="descclassname">FDBWorkload::</code><code class="descname">setup</code><span class="sig-paren">(</span>FDBDatabase *<em>db</em>, GenericPromise&lt;bool&gt; <em>done</em><span class="sig-paren">)</span><br /></dt>
<dd><p>This method will be called by the tester during the setup phase. It should be used to populate the database.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N11FDBWorkload5startEP11FDBDatabase14GenericPromiseIbE">
<span id="FDBWorkload::start__FDBDatabaseP.GenericPromise:b:"></span>void <code class="descclassname">FDBWorkload::</code><code class="descname">start</code><span class="sig-paren">(</span>FDBDatabase *<em>db</em>, GenericPromise&lt;bool&gt; <em>done</em><span class="sig-paren">)</span><br /></dt>
<dd><p>This method should run the actual test.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N11FDBWorkload5checkEP11FDBDatabase14GenericPromiseIbE">
<span id="FDBWorkload::check__FDBDatabaseP.GenericPromise:b:"></span>void <code class="descclassname">FDBWorkload::</code><code class="descname">check</code><span class="sig-paren">(</span>FDBDatabase *<em>db</em>, GenericPromise&lt;bool&gt; <em>done</em><span class="sig-paren">)</span><br /></dt>
<dd><p>When the tester completes, this method will be called. A workload should run any consistency/correctness tests
during this phase.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK11FDBWorkload10getMetricsERNSt6vectorI13FDBPerfMetricEE">
<span id="FDBWorkload::getMetrics__std::vector:FDBPerfMetric:RC"></span>void <code class="descclassname">FDBWorkload::</code><code class="descname">getMetrics</code><span class="sig-paren">(</span>std::vector&lt;FDBPerfMetric&gt; &amp;<em>out</em><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>If a workload collects metrics (like latencies or throughput numbers), these should be reported back here.
The multitester (or test orchestrator) will collect all metrics from all test clients and it will aggregate them.</p>
</dd></dl>

</div>
<div class="section" id="implementing-a-java-workload">
<h2>Implementing a Java Workload</h2>
<p>In order to implement your own workload in Java you can simply create an implementation of the abstract class <code class="docutils literal"><span class="pre">AbstractWorkload</span></code>.
A minimal implementation will look like this:</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="kn">package</span><span class="w"> </span><span class="nn">my.package</span><span class="p">;</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">com.apple.foundationdb.testing.Promise</span><span class="p">;</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">com.apple.foundationdb.testing.AbstractWorkload</span><span class="p">;</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">com.apple.foundationdb.testing.WorkloadContext</span><span class="p">;</span><span class="w"></span>

<span class="kd">class</span> <span class="nc">MinimalWorkload</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">AbstractWorkload</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">MinimalWorkload</span><span class="p">(</span><span class="n">WorkloadContext</span><span class="w"> </span><span class="n">ctx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">super</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="nd">@Override</span><span class="w"></span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="n">Database</span><span class="w"> </span><span class="n">db</span><span class="p">,</span><span class="w"> </span><span class="n">Promise</span><span class="w"> </span><span class="n">promise</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">log</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;WorkloadSetup&quot;</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">promise</span><span class="p">.</span><span class="na">send</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="nd">@Override</span><span class="w"></span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">start</span><span class="p">(</span><span class="n">Database</span><span class="w"> </span><span class="n">db</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">log</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;WorkloadStarted&quot;</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">promise</span><span class="p">.</span><span class="na">send</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="nd">@Override</span><span class="w"></span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">check</span><span class="p">(</span><span class="n">Database</span><span class="w"> </span><span class="n">db</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">log</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;WorkloadFailureCheck&quot;</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">promise</span><span class="p">.</span><span class="na">send</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The lifecycle of a test will look like this:</p>
<ol class="arabic simple">
<li>All testers will create an instance of the <code class="docutils literal"><span class="pre">AbstractWorkload</span></code> implementation.</li>
<li>All testers will (in parallel but not guaranteed exactly at the same time) call
<code class="docutils literal"><span class="pre">setup</span></code> and they will wait for all of them to finish. This phase can be used to
pre-populate data.</li>
<li>All tester will then call start (again, in parallel) and wait for all of them to
finish.</li>
<li>All testers will then call <code class="docutils literal"><span class="pre">check</span></code> on all testers and use the returned boolean
to determine whether the test succeeded.</li>
</ol>
<p>All these methods take a <code class="docutils literal"><span class="pre">Database</span></code> object as an argument. This object can be used
to create and execute transactions against the cluster.</p>
<p>When implementing workloads, an author has to follow these rules:</p>
<ul class="simple">
<li>To write tracing to the trace-files one should use <code class="docutils literal"><span class="pre">AbstractWorkload.log</span></code>. This
Method takes three arguments: an integer for severity (5 means debug, 10 means log,
20 means warning, 30 means warn always, and 40 is a severe error). If any tester
logs something of severity 40, the test run is considered to have failed.</li>
<li>In order to increase throughput on the cluster, an author might want to spawn several
threads. However, threads <em>MUST</em> only be spawn through the <code class="docutils literal"><span class="pre">Executor</span></code> instance one
can get from <code class="docutils literal"><span class="pre">AbstractWorkload.getExecutor()</span></code>. Otherwise, a simulation test will
probably segfault. The reason for this is that we need to keep track of which simulated
machine a thread corresponds to internally.</li>
</ul>
<p>Within a workload you have access to the <code class="docutils literal"><span class="pre">WorkloadContext</span></code> which provides additional
information about the current execution environment. The context can be accessed through
<code class="docutils literal"><span class="pre">this.context</span></code> and provides the following methods:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">String</span> <span class="pre">getOption(String</span> <span class="pre">name,</span> <span class="pre">String</span> <span class="pre">defaultValue)</span></code>. A user can provide parameters to workloads
through a configuration file (explained further down). These parameters are provided to
all clients through the context and can be accessed with this method.</li>
<li><code class="docutils literal"><span class="pre">int</span> <span class="pre">getClientId()</span></code> and <code class="docutils literal"><span class="pre">int</span> <span class="pre">getClientCount()</span></code>. An author can determine how many
clients are running in the cluster and each of those will get a globally unique ID (a number
between 0 and clientCount - 1). This is useful for example if you want to generate transactions
that are guaranteed to not conflict with transactions from other clients.</li>
<li><code class="docutils literal"><span class="pre">int</span> <span class="pre">getSharedRandomNumber()</span></code>. At startup a random number will be generated. This will allow for
generating the same random numbers across several machines if this number is used as a seed.</li>
</ul>
</div>
<div class="section" id="running-a-workload-in-the-simulator">
<h2>Running a Workload in the Simulator</h2>
<p>We&#8217;ll first walk how one can run a workload in a simulator. FoundationDB comes already with a large number
of workloads. But some of them can&#8217;t be run in simulation while other don&#8217;t work on a real cluster. Most
will work on both though. To look for examples how these can be ran, you can find configuration files in
the <code class="docutils literal"><span class="pre">tests</span></code> directory in the FoundationDB source tree.</p>
<p>We will now go through an example how you can write a relatively complex test and run it in the simulator.
Writing and running tests in the simulator is a simple two-step process.</p>
<ol class="arabic simple">
<li>Write the test.</li>
<li>Run <code class="docutils literal"><span class="pre">fdbserver</span></code> in simulation mode and provide it with the test file.</li>
</ol>
<div class="section" id="write-the-test">
<h3>Write the Test</h3>
<p>A workload is not a test. A test is a simple test file that tells the test orchestrator which workloads it
should run and in which order. Additionally one can provide parameters to workloads through this file.</p>
<p>A test file might look like this:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>testTitle=MyTest
  testName=External
  libraryName=java_workloads
  workloadName=my.package.MinimalWorkload
  classPath=PATH_TO_JAR_OR_DIR_CONTAINING_WORKLOAD,OTHER_DEPENDENCIES

  testName=Attrition
  testDuration=5.0
  reboot=true
  machinesToKill=3

testTitle=AnotherTest
  testName=External
  libraryName=java_workloads
  workloadName=my.package.MinimalWorkload
  classPath=PATH_TO_JAR_OR_DIR_CONTAINING_WORKLOAD,OTHER_DEPENDENCIES
  someOption=foo

  testName=External
  libraryName=java_workloads
  workloadName=my.package.AnotherWorkload
  classPath=PATH_TO_JAR_OR_DIR_CONTAINING_WORKLOAD,OTHER_DEPENDENCIES
  anotherOption=foo
</pre></div>
</div>
<p>This test will do the following:</p>
<ol class="arabic simple">
<li>First it will run <code class="docutils literal"><span class="pre">MinimalWorkload</span></code> without any parameter.</li>
<li>After 5.0 seconds the simulator will reboot 3 random machines (this is what Attrition does
and this workload is provided by FoundationDB. This is one of the few workloads that only
work in the simulator).</li>
<li>When all workloads are finished, it will run <code class="docutils literal"><span class="pre">MinimalWorkload</span></code>
again. This time it will have the option <code class="docutils literal"><span class="pre">someOption</span></code> set to
<code class="docutils literal"><span class="pre">foo</span></code>. Additionally it will run <code class="docutils literal"><span class="pre">AnotherWorkload</span></code> in parallel.</li>
</ol>
<div class="section" id="how-to-set-the-class-path-correctly">
<h4>How to set the Class Path correctly</h4>
<p>As you can see from above example, we can set the classpath through two different mechanisms. However, one has
to be careful as they can&#8217;t be used interchangeably.</p>
<ul class="simple">
<li>You can set a class path through the JVM argument <code class="docutils literal"><span class="pre">-Djava.class.path=...</span></code>. This is how you have to pass the
path to the FoundationDB client library (as the client library is needed during the initialization phase). However,
only the first specified section will have any effect as the other Workloads will run in the same VM (and arguments,
by nature, can only be passed once).</li>
<li>The <code class="docutils literal"><span class="pre">classPath</span></code> option. This option will add all paths (directories or JAR-files) to the classPath of the JVM
while it is running. Not being able to add the path will result in a test failure. This is useful to add different
dependencies to different workloads. A path can appear more than once across sections. However, they must not
conflict with each other as we never remove something from the classpath.</li>
</ul>
</div>
</div>
<div class="section" id="run-the-simulator">
<h3>Run the simulator</h3>
<p>This step is very simple. You can simply run <code class="docutils literal"><span class="pre">fdbserver</span></code> with role simulator
and pass the test with <code class="docutils literal"><span class="pre">-f</span></code>:</p>
<div class="highlight-sh"><div class="highlight"><pre><span></span>fdbserver -r simulation -f testfile.txt
</pre></div>
</div>
</div>
</div>
<div class="section" id="running-a-workload-on-an-actual-cluster">
<h2>Running a Workload on an actual Cluster</h2>
<p>Running a workload on a cluster works basically the smae way. However, one must
actually setup a cluster first. This cluster must run between one and many server
processes with the class test. So above 2-step process becomes a bit more complex:</p>
<ol class="arabic simple">
<li>Write the test (same as above).</li>
<li>Set up a cluster with as many test clients as you want.</li>
<li>Run the orchestrator to actually execute the test.</li>
</ol>
<p>Step 1. is explained further up. For step 2., please refer to the general FoundationDB
configuration. The main difference to a normal FoundationDB cluster is that some processes
must have a test class assigned to them. This can be done in the <code class="docutils literal"><span class="pre">foundationdb.conf</span></code>. For
example this file would create a server with 8 processes of which 4 would act as test clients.</p>
<div class="highlight-ini"><div class="highlight"><pre><span></span><span class="k">[fdbmonitor]</span><span class="w"></span>
<span class="na">user</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">foundationdb</span><span class="w"></span>
<span class="na">group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">foundationdb</span><span class="w"></span>

<span class="k">[general]</span><span class="w"></span>
<span class="na">restart-delay</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">60</span><span class="w"></span>
<span class="na">cluster-file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">/etc/foundationdb/fdb.cluster</span><span class="w"></span>

<span class="c1">## Default parameters for individual fdbserver processes</span><span class="w"></span>
<span class="k">[fdbserver]</span><span class="w"></span>
<span class="na">command</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">/usr/sbin/fdbserver</span><span class="w"></span>
<span class="na">public-address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">auto:$ID</span><span class="w"></span>
<span class="na">listen-address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">public</span><span class="w"></span>
<span class="na">datadir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">/var/lib/foundationdb/data/$ID</span><span class="w"></span>
<span class="na">logdir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">/var/log/foundationdb</span><span class="w"></span>

<span class="k">[fdbserver.4500]</span><span class="w"></span>
<span class="k">[fdbserver.4501]</span><span class="w"></span>
<span class="k">[fdbserver.4502]</span><span class="w"></span>
<span class="k">[fdbserver.4503]</span><span class="w"></span>
<span class="k">[fdbserver.4510]</span><span class="w"></span>
<span class="na">class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">test</span><span class="w"></span>
<span class="k">[fdbserver.4511]</span><span class="w"></span>
<span class="na">class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">test</span><span class="w"></span>
<span class="k">[fdbserver.4512]</span><span class="w"></span>
<span class="na">class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">test</span><span class="w"></span>
<span class="k">[fdbserver.4513]</span><span class="w"></span>
<span class="na">class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">test</span><span class="w"></span>
</pre></div>
</div>
<p>Running the actual test can be done with <code class="docutils literal"><span class="pre">fdbserver</span></code> as well. For this you can call the process
with the <code class="docutils literal"><span class="pre">multitest</span></code> role:</p>
<div class="highlight-sh"><div class="highlight"><pre><span></span>fdbserver -r multitest -f testfile.txt
</pre></div>
</div>
<p>This command will block until all tests are completed.</p>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="_sources/client-testing.rst.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2013-2021 Apple, Inc and the FoundationDB project authors.<br/>
      Last updated on Apr 28, 2022.<br/>
    </p>
  </div>
</footer>
  </body>
</html>